SmoothSpline
============

[![Build Status](https://github.com/robertdj/SmoothSpline.jl/workflows/CI/badge.svg)](https://github.com/robertdj/SmoothSpline.jl/actions)
[![codecov.io](https://codecov.io/github/robertdj/SmoothSpline.jl/coverage.svg?branch=master)](https://codecov.io/github/robertdj/SmoothSpline.jl?branch=master)

The *SmoothSpline* package is a port of R's `smooth.spline` function for regression with cubic B-splines.
My original goal was to get "exactly" the same results as `smooth.spline`.

There is already a similar package for this kind of regression, namely the [SmoothingSplines package](https://github.com/nignatiadis/SmoothingSplines.jl).
But *SmoothingSplines* aim to "provide the same functionality as R's `smooth.spline` function", but "the implementation however is completely independent of the R function".

Along the way I discovered discrepancies between the R/Fortran *implementation* and the math. 
I implement the math correctly, but also *test* against the R/Fortran implementation.
All the bloody details are in `doc/splines.pdf`.

The *SmoothSpline* package is currently quite self-contained, because a sub-goal was to get a better understanding of how spline regression works.
For example, I provide all functionality for working with B-splines instead of relying on other packages to do this.


# Installation

SmoothSpline is not registered as an official package.


# Usage

As an example, we make a regression with the classic `mtcars` dataset from R and compare 

```julia
import LinearAlgebra
using Mocking
using Plots
using RCall
using SmoothSpline
```

First we perform the regression in R using the [RCall package](https://github.com/JuliaInterop/RCall.jl).
The `spar` parameter should be in the interval `(0, 1]` and controls the sensitivity to outliers.

```julia
spar = 0.7
spline_model_r = RCall.rcopy(R"spline_model <- smooth.spline(mtcars[['hp']], mtcars[['mpg']], spar = $spar)");
spline_model_r = RCall.rcopy(R"spline_model <- smooth.spline(cars[['speed']], cars[['dist']], spar = $spar)");
```

We can make predictions with this model to compare with the predictions from *SmoothSpline*.

```julia
obs_x = spline_model_r[:data][:x]
obs_y = spline_model_r[:data][:y]
x = range(extrema(obs_x)...; step = 1)
predictions_r = RCall.rcopy(R"predict(spline_model, $x)");
```

In Julia with SmoothSpline using the same data

```julia
spline_model = SmoothSpline.smooth_spline(obs_x, obs_y, spar)
predictions_julia = SmoothSpline.predict(spline_model, x);
```

We can now visually compare the two regression lines.

```julia; label = "predictions"
scatter(obs_x, obs_y, label = "data", legend = :topleft)
plot!(predictions_r[:x], predictions_r[:y], label = "R")
plot!(x, predictions_julia, label = "julia")
```

The R coefficients and their order of magnitude

```julia
coef_r = spline_model_r[:fit][:coef]
extrema(coef_r)
```

The differences between the R coefficients and Julia coefficients:

```julia
@show maximum(abs, coef_r - spline_model.Coef)
maximum(abs, predictions_r[:y] - predictions_julia)
```


## Discrepancies

With the [Mocking package](https://github.com/invenia/Mocking.jl) we can emulate `smooth.spline`'s behavior with *SmoothSpline*.
The reason for these mocks are explained in `doc/splines.pdf`, so I wont comment further on the motivation here.

```julia
Mocking.activate()

patch1 = @patch SmoothSpline.OneThird() = 0.333
spline_model_like_R = apply(patch1) do
    SmoothSpline.smooth_spline(obs_x, obs_y, spar)
end

patch2 = @patch SmoothSpline.tr(A, lead, lag) = LinearAlgebra.tr(A)
spline_model_tr = apply(patch2) do
    SmoothSpline.smooth_spline(obs_x, obs_y, spar)
end

maximum(abs, coef_r - spline_model_tr.Coef)
```

One of the models is "exactly" like R's:

```julia
maximum(abs, coef_r - spline_model_like_R.Coef)
```

Comparing the models visually

```julia; label = "comparison"
scatter(obs_x, obs_y, label = "data", legend = :topleft)
plot!(x, SmoothSpline.predict(spline_model_like_R, x), label = "R")
plot!(x, SmoothSpline.predict(spline_model_tr, x), label = "julia")
```


# License

I have been scrutinizing the source code of R's `smooth.spline`.
R is licensed under GPL and I have therefore created a "derivative work" that also has to be licensed under GPL.

To spare others of this I have included a description of the math used in *SmoothSpline* in the `doc` folder of this repo.
Since this document does not contain code it should supposedly remove the yoke of the GPL if others implement similar functionality *based on the document*.

**Please note**: This is not legal advice, but based on my understanding of the GPL.


# Technical details

*SmoothSpline* is currently proof-of-concept code and I have focused on correctness and not e.g. optimizing execution speed.
I know of the following points that (c|sh)ould be improved:

- All algorithms related to spline evaluation are based on a book that use 0-indexed arrays. Instead of translating this to 1-indexed arrays I rely on the [OffsetArrays package](https://github.com/JuliaArrays/OffsetArrays.jl).
- Evaluation of the Gram matrix make an abundance of calls for spline function values.
- The design matrix and Gram matrices are banded and therefore admits compact representations like in the [BandedMatrices package](https://github.com/JuliaMatrices/BandedMatrices.jl). I save them as dense matrices.
- There are fast algorithms for solving linear equations with banded (semi-)definite matrices. I use a LAPACK solver for dense matrices.


# Reproducibility

This README is generated with the [Weave package](https://github.com/JunoLab/Weave.jl) using the command

```julia; eval = false
weave("README.jmd", doctype = "github", fig_path = "figures")
```

My Julia version is

```julia
import InteractiveUtils
InteractiveUtils.versioninfo()
```

For the R calls I am using

```julia
RCall.reval("sessionInfo()")
```
